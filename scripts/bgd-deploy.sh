#!/bin/bash
#
# bgd-deploy.sh - Deployment script for Blue/Green Deployment
#
# This script manages the deployment of applications using the
# blue/green deployment strategy.

set -euo pipefail

# Get script directory and load core module
BGD_SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$BGD_SCRIPT_DIR/bgd-core.sh"

# Display help information
bgd_show_help() {
  cat << EOL
=================================================================
Blue/Green Deployment System - Deployment Script
=================================================================

USAGE:
  ./bgd-deploy.sh VERSION [OPTIONS]

ARGUMENTS:
  VERSION             Version to deploy (required)

OPTIONS:
  --app-name=NAME     Application name
  --image-repo=REPO   Docker image repository
  --image-tag=TAG     Docker image tag (defaults to VERSION)
  --blue-port=PORT    Port for blue environment (default: 8081)
  --green-port=PORT   Port for green environment (default: 8082)
  --domain-name=DOMAIN  Domain name for application
  --domain-aliases=LIST Comma-separated list of domain aliases
  --health-endpoint=PATH Health check endpoint (default: /health)
  --health-retries=NUM  Health check retry attempts (default: 12)
  --health-delay=SEC    Delay between health checks (default: 5)
  --ssl-enabled         Enable SSL configuration
  --profile=NAME        Use specific configuration profile
  --env-file=PATH       Path to environment file
  --docker-network=NAME Docker network to use
  --target-env=ENV      Target specific environment (blue|green)
  --cutover             Automatically cut over traffic after deploy
  --db-migrations       Run database migrations
  --skip-health-check   Skip health check verification
  --clean-before        Clean target environment before deploying
  --force               Force deployment even if health checks fail
  --quiet               Suppress detailed output
  --help                Show this help message

EXAMPLES:
  # Basic deployment with automatic environment selection
  ./bgd-deploy.sh 1.0.0 --app-name=myapp --image-repo=ghcr.io/myorg/myapp

  # Deploy with custom ports and health checks
  ./bgd-deploy.sh 1.0.0 --app-name=myapp --image-repo=ghcr.io/myorg/myapp \
    --blue-port=3001 --green-port=3002 --health-endpoint=/status

  # Deploy with SSL and automatic cutover
  ./bgd-deploy.sh 1.0.0 --app-name=myapp --image-repo=ghcr.io/myorg/myapp \
    --domain-name=myapp.example.com --ssl-enabled --cutover

=================================================================
EOL
}

# Validate required parameters
bgd_validate_parameters() {
  # Check for required parameters
  if [ -z "${VERSION:-}" ]; then
    bgd_log "Missing required parameter: VERSION" "error"
    bgd_show_help
    exit 1
  fi
  
  if [ -z "${APP_NAME:-}" ]; then
    bgd_log "Missing required parameter: APP_NAME" "error"
    bgd_show_help
    exit 1
  fi
  
  if [ -z "${IMAGE_REPO:-}" ]; then
    bgd_log "Missing required parameter: IMAGE_REPO" "error"
    bgd_show_help
    exit 1
  fi
  
  # Set default values for optional parameters
  BLUE_PORT="${BLUE_PORT:-8081}"
  GREEN_PORT="${GREEN_PORT:-8082}"
  IMAGE_TAG="${IMAGE_TAG:-$VERSION}"
  HEALTH_ENDPOINT="${HEALTH_ENDPOINT:-/health}"
  HEALTH_RETRIES="${HEALTH_RETRIES:-12}"
  HEALTH_DELAY="${HEALTH_DELAY:-5}"
  SKIP_HEALTH_CHECK="${SKIP_HEALTH_CHECK:-false}"
  CUTOVER="${CUTOVER:-false}"
  FORCE="${FORCE:-false}"
  CLEAN_BEFORE="${CLEAN_BEFORE:-false}"
  SSL_ENABLED="${SSL_ENABLED:-false}"
  DB_MIGRATIONS="${DB_MIGRATIONS:-false}"
  
  # Determine docker image to use
  if [ -z "${IMAGE:-}" ]; then
    # Default image format is repo:tag
    IMAGE="${IMAGE_REPO}:${IMAGE_TAG}"
  fi
  
  return 0
}

# Prepare deployment environment
bgd_prepare_environment() {
  local target_env="$1"
  local app_name="$2"
  local version="$3"
  
  bgd_log "Preparing $target_env environment for $app_name version $version" "info"
  
  # Create app directory if it doesn't exist
  local app_dir="./apps/$app_name"
  if ! bgd_ensure_directory "$app_dir"; then
    return 1
  fi
  
  # Clean environment if requested
  if [ "${CLEAN_BEFORE:-false}" = "true" ]; then
    bgd_log "Cleaning $target_env environment before deployment" "info"
    
    local cleanup_script="${BGD_SCRIPT_DIR}/bgd-cleanup.sh"
    if [ -f "$cleanup_script" ] && [ -x "$cleanup_script" ]; then
      "$cleanup_script" --app-name="$app_name" --environment="$target_env" --force || {
        bgd_log "Cleanup failed but continuing with deployment" "warning"
      }
    else
      bgd_log "Cleanup script not found: $cleanup_script" "warning"
    }
  fi
  
  # Create environment file with deployment variables
  local env_file="$app_dir/.env"
  
  # Start with custom env file if provided
  if [ -n "${ENV_FILE:-}" ] && [ -f "$ENV_FILE" ]; then
    cp "$ENV_FILE" "$env_file"
  else
    # Create new env file from scratch
    cat > "$env_file" << EOL
# Generated by BGD Deploy Script
# Application: $app_name
# Version: $version
# Deployment Date: $(date)
# Environment: $target_env

# Application configuration
APP_NAME=$app_name
VERSION=$version
IMAGE=$IMAGE

# Environment configuration
ENV_NAME=$target_env
BLUE_PORT=$BLUE_PORT
GREEN_PORT=$GREEN_PORT
HEALTH_ENDPOINT=$HEALTH_ENDPOINT
HEALTH_RETRIES=$HEALTH_RETRIES
HEALTH_DELAY=$HEALTH_DELAY

# Networking configuration
EOL
    
    # Add domain info if provided
    if [ -n "${DOMAIN_NAME:-}" ]; then
      cat >> "$env_file" << EOL
DOMAIN_NAME=$DOMAIN_NAME
DOMAIN_ALIASES=${DOMAIN_ALIASES:-}
EOL
    fi
    
    # Add SSL info if enabled
    if [ "${SSL_ENABLED:-false}" = "true" ]; then
      cat >> "$env_file" << EOL
SSL_ENABLED=true
EOL
    fi
    
    # Add Docker network info if provided
    if [ -n "${DOCKER_NETWORK:-}" ]; then
      cat >> "$env_file" << EOL
DOCKER_NETWORK=$DOCKER_NETWORK
USE_EXTERNAL_NETWORK=true
EOL
    fi
  fi
  
  # Save environment-specific variables
  local env_specific_file="$app_dir/.env.$target_env"
  cat > "$env_specific_file" << EOL
# Environment-specific configuration for $target_env
ENV_NAME=$target_env
EOL
  
  # Set port based on environment
  if [ "$target_env" = "blue" ]; then
    echo "PORT=$BLUE_PORT" >> "$env_specific_file"
  else
    echo "PORT=$GREEN_PORT" >> "$env_specific_file"
  fi
  
  # Create docker-compose.yml if it doesn't exist
  local compose_file="$app_dir/docker-compose.yml"
  if [ ! -f "$compose_file" ]; then
    # Check if template exists in base directory
    local template_file="${BGD_BASE_DIR}/docker-compose.template.yml"
    
    if [ -f "$template_file" ]; then
      cp "$template_file" "$compose_file"
    else
      # Create a basic docker-compose file
      cat > "$compose_file" << EOL
version: '3.8'

services:
  app:
    image: \${IMAGE}
    environment:
      - NODE_ENV=\${NODE_ENV:-production}
      - PORT=\${PORT:-3000}
      - VERSION=\${VERSION:-latest}
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:\${PORT:-3000}\${HEALTH_ENDPOINT:-/health}"]
      interval: 10s
      timeout: 5s
      retries: \${HEALTH_RETRIES:-12}
      start_period: 15s
    volumes:
      - app-data:/app/data

  nginx:
    image: nginx:stable-alpine
    ports:
      - "\${NGINX_PORT:-80}:80"
      - "\${NGINX_SSL_PORT:-443}:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./nginx:/etc/nginx:ro
      - ./certs:/etc/nginx/certs:ro
    depends_on:
      - app

volumes:
  app-data:
EOL
    fi
  fi
  
  # Create override file for environment-specific settings
  if [ -f "${BGD_TEMPLATES_DIR}/docker-compose.override.template" ]; then
    # Use template processor if available
    if [ -f "${BGD_SCRIPT_DIR}/bgd-nginx-template.sh" ]; then
      source "${BGD_SCRIPT_DIR}/bgd-nginx-template.sh"
      
      # Set environment variables for template
      export APP_NAME="$app_name"
      export ENV_NAME="$target_env"
      export VERSION="$version"
      export TIMESTAMP="$(date)"
      
      # Process template
      bgd_process_template "${BGD_TEMPLATES_DIR}/docker-compose.override.template" \
        "$app_dir/docker-compose.override.yml"
    else
      # Simple copy of template
      cp "${BGD_TEMPLATES_DIR}/docker-compose.override.template" \
        "$app_dir/docker-compose.override.yml"
    fi
  fi
  
  # Change to app directory
  cd "$app_dir" || {
    bgd_log "Failed to change to directory: $app_dir" "error"
    return 1
  }
  
  bgd_log "Environment preparation completed" "success"
  return 0
}

# Deploy to specified environment
bgd_deploy_to_environment() {
  local target_env="$1"
  local app_name="$2"
  local version="$3"
  
  bgd_log "Beginning deployment of $app_name version $version to $target_env environment" "info"
  
  # Load plugins for deployment
  bgd_load_plugins
  
  # Call pre-deploy hook if implemented
  if declare -F bgd_hook_pre_deploy >/dev/null; then
    bgd_hook_pre_deploy "$version" "$app_name" || {
      bgd_log "Pre-deploy hook failed" "warning"
    }
  fi
  
  # Prepare environment
  if ! bgd_prepare_environment "$target_env" "$app_name" "$version"; then
    bgd_log "Failed to prepare environment" "error"
    return 1
  fi
  
  # Get Docker Compose command
  local docker_compose=$(bgd_get_docker_compose_cmd)
  if [ -z "$docker_compose" ]; then
    bgd_log "Docker Compose command not found" "error"
    return 1
  fi
  
  # Stop any existing containers in the target environment
  bgd_log "Stopping existing containers in $target_env environment" "info"
  $docker_compose -p "${app_name}-${target_env}" down || {
    bgd_log "Failed to stop existing containers, but continuing" "warning"
  }
  
  # Pull the Docker image
  bgd_log "Pulling Docker image: $IMAGE" "info"
  $docker_compose -p "${app_name}-${target_env}" pull || {
    bgd_log "Failed to pull Docker image" "error"
    return 1
  }
  
  # Start the environment
  bgd_log "Starting $target_env environment" "info"
  $docker_compose -p "${app_name}-${target_env}" up -d || {
    bgd_log "Failed to start environment" "error"
    return 1
  }
  
  # Call post-environment-start hook if implemented
  if declare -F bgd_hook_post_env_start >/dev/null; then
    bgd_hook_post_env_start "$target_env" || {
      bgd_log "Post-environment-start hook failed" "warning"
    }
  fi
  
  # Create Nginx configuration
  bgd_log "Creating Nginx configuration for $target_env environment" "info"
  
  if ! bgd_create_single_env_nginx_conf "$target_env"; then
    bgd_log "Failed to create Nginx configuration" "error"
    return 1
  fi
  
  # Run health checks unless skipped
  if [ "${SKIP_HEALTH_CHECK:-false}" != "true" ]; then
    bgd_log "Running health checks for $target_env environment" "info"
    
    if ! bgd_check_environment_health "$target_env" "$app_name"; then
      if [ "${FORCE:-false}" != "true" ]; then
        bgd_log "Health checks failed and --force not specified, aborting deployment" "error"
        return 1
      else
        bgd_log "Health checks failed but continuing due to --force flag" "warning"
      fi
    else
      bgd_log "Health checks passed, deployment is ready" "success"
    fi
  else
    bgd_log "Health checks skipped as requested" "warning"
  fi
  
  # Call post-deploy hook if implemented
  if declare -F bgd_hook_post_deploy >/dev/null; then
    bgd_hook_post_deploy "$version" "$target_env" || {
      bgd_log "Post-deploy hook failed" "warning"
    }
  fi
  
  bgd_log "Deployment to $target_env environment completed successfully" "success"
  return 0
}

# Perform the deployment
bgd_deploy() {
  local version="$1"
  local app_name="$2"
  
  # Determine target environment
  local target_env="${TARGET_ENV:-}"
  if [ -z "$target_env" ]; then
    # Get current active/inactive environments
    read active_env inactive_env <<< $(bgd_get_environments)
    target_env="$inactive_env"
  fi
  
  # Override target_env if debug mode is active
  if [ "${DEBUG_KEEP_ENVIRONMENT:-false}" = "true" ]; then
    read active_env inactive_env <<< $(bgd_get_environments)
    target_env="$active_env"
    bgd_log "DEBUG: Deploying to active environment: $target_env" "warning"
  fi
  
  bgd_log "Target environment: $target_env" "info"
  
  # Deploy to target environment
  if bgd_deploy_to_environment "$target_env" "$app_name" "$version"; then
    bgd_log "Deployment successful" "success"
    
    # Perform cutover if requested
    if [ "${CUTOVER:-false}" = "true" ]; then
      bgd_log "Automatic cutover requested, switching traffic to $target_env" "info"
      
      local cutover_script="${BGD_SCRIPT_DIR}/bgd-cutover.sh"
      if [ -f "$cutover_script" ] && [ -x "$cutover_script" ]; then
        "$cutover_script" --app-name="$app_name" --target="$target_env" || {
          bgd_log "Cutover failed" "error"
          return 1
        }
        
        bgd_log "Cutover completed successfully" "success"
      else
        bgd_log "Cutover script not found: $cutover_script" "error"
        return 1
      fi
    else
      # No cutover, just provide information on how to cut over
      bgd_log "Deployment complete. To cut over to the new environment, run:" "info"
      bgd_log "  ${BGD_SCRIPT_DIR}/bgd-cutover.sh --app-name=$app_name --target=$target_env" "info"
    fi
    
    return 0
  else
    bgd_log "Deployment failed" "error"
    return 1
  fi
}

# Main function
bgd_main() {
  # Check if version is provided
  if [ $# -eq 0 ]; then
    bgd_show_help
    exit 1
  fi
  
  # First parameter is the version
  local version="$1"
  shift
  
  # Parse command line arguments
  bgd_parse_parameters "$@"
  
  # Show help if requested
  if [ "${HELP:-false}" = "true" ]; then
    bgd_show_help
    exit 0
  fi
  
  # Set version from first parameter
  export VERSION="$version"
  
  # Validate required parameters
  bgd_validate_parameters
  
  # Start the deployment
  if bgd_deploy "$VERSION" "${APP_NAME}"; then
    bgd_log "Operation completed successfully" "success"
    exit 0
  else
    bgd_log "Operation failed" "error"
    exit 1
  fi
}

# Execute main function if script is being run directly
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  bgd_main "$@"
fi